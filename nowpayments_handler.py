import requests
import hmac
import hashlib
import json
import logging
from config import NOWPAYMENTS_API_KEY, IPN_SECRET_KEY
from database_manager import activate_subscription

logger = logging.getLogger(__name__)

NOWPAYMENTS_API_KEY = NOWPAYMENTS_API_KEY.strip() if NOWPAYMENTS_API_KEY else ""
if NOWPAYMENTS_API_KEY.startswith("sandbox"):
    NOWPAYMENTS_API_URL = "https://api-sandbox.nowpayments.io/v1"
else:
    NOWPAYMENTS_API_URL = "https://api.nowpayments.io/v1"

def create_payment_invoice(amount_usd: float, user_id: int, description: str = "subscription") -> dict:
    """
    Creates a payment invoice on NOWPayments.
    description: "subscription" for Premium membership, "200_credits", "400_credits", etc for credit packages
    Returns a dict with 'invoice_url' and 'invoice_id' or None on failure.
    """
    if not NOWPAYMENTS_API_KEY:
        logger.error("NOWPAYMENTS_API_KEY is not set")
        return None
        
    logger.info(f"Using NOWPayments API URL: {NOWPAYMENTS_API_URL}")
    logger.info(f"API Key starts with: {NOWPAYMENTS_API_KEY[:4]}***")

    headers = {
        "x-api-key": NOWPAYMENTS_API_KEY,
        "Content-Type": "application/json"
    }
    
    # Determine order description based on type
    if description == "subscription":
        order_desc = "Suscripción Premium KaliBot (30 días + 250 créditos bonus)"
    elif "credits" in description:
        credits_amount = description.split("_")[0]
        order_desc = f"Recarga de {credits_amount} Créditos IA - KaliBot"
    else:
        order_desc = f"KaliBot - {description}"
    
    payload = {
        "price_amount": amount_usd,
        "price_currency": "usd",
        "pay_currency": "usdttrc20", # USDT on TRC-20
        # "ipn_callback_url": "", # Will be set in dashboard or we can override if needed, but usually dashboard is better or we pass it here if we have a public URL.
        # Since we don't know the public URL dynamically easily without config, we assume the dashboard has the IPN set to our webhook,
        # OR we can try to pass it if we have TELEGRAM_WEBHOOK_URL.
        "order_id": f"{user_id}_{description}_{int(__import__('time').time())}", # Unique order ID
        "order_description": order_desc
    }
    
    # If we have a webhook URL configured, let's append the path
    from config import TELEGRAM_WEBHOOK_URL
    if TELEGRAM_WEBHOOK_URL:
        # Assuming TELEGRAM_WEBHOOK_URL is like https://.../webhook/telegram
        # We want https://.../webhook/nowpayments
        base_url = TELEGRAM_WEBHOOK_URL.rsplit('/', 2)[0] # remove /webhook/telegram
        if '/webhook' in TELEGRAM_WEBHOOK_URL:
             base_url = TELEGRAM_WEBHOOK_URL.split('/webhook')[0]
        
        payload["ipn_callback_url"] = f"{base_url}/webhook/nowpayments"

    try:
        response = requests.post(f"{NOWPAYMENTS_API_URL}/invoice", headers=headers, json=payload)
        response.raise_for_status()
        data = response.json()
        
        return {
            "invoice_url": data.get("invoice_url"),
            "invoice_id": data.get("id"),
            "payment_type": description  # Store type for webhook processing
        }
    except Exception as e:
        logger.exception(f"Error creating NOWPayments invoice: {e}")
        if 'response' in locals():
            logger.error(f"Response content: {response.text}")
        return None

async def process_nowpayments_webhook(request_body: bytes, signature_header: str) -> dict:
    """
    Verifies IPN signature and processes the payment update.
    """
    if not IPN_SECRET_KEY:
        logger.error("IPN_SECRET_KEY is not set")
        return {"status": 500, "message": "Server configuration error"}

    # Verify signature
    # NOWPayments sorts keys and signs the string representation of the JSON?
    # Actually, the docs say: "Sort all the parameters in the request alphabetically... Convert to string... Sign with HMAC-SHA512"
    # BUT, usually they send a header 'x-nowpayments-sig'.
    # Let's re-read the docs or standard practice.
    # Docs: "The IPN request contains the x-nowpayments-sig header... The signature is generated by taking the JSON body of the request..."
    # Wait, some docs say sort params.
    # Let's assume standard HMAC-SHA512 of the body for now, but if it fails we might need to sort.
    # "Sort the dictionary by keys... concatenate values..." -> This is for some APIs.
    # NOWPayments docs: "Sort all the parameters in the request alphabetically. ... create a string ... key=value&key=value..."
    # Actually, if we receive a JSON body, we might just need to sign the raw body if the header signs the body.
    # However, usually IPN sends JSON.
    # Let's try to verify the signature by sorting keys as per common NOWPayments examples.
    
    try:
        payload = json.loads(request_body)
    except json.JSONDecodeError:
        return {"status": 400, "message": "Invalid JSON"}

    # Verification logic
    # 1. Sort keys alphabetically
    sorted_keys = sorted(payload.keys())
    # 2. Create string
    # Note: NOWPayments documentation can be tricky.
    # If the signature is based on the raw body, we just hmac the request_body.
    # If it's based on sorted params, we construct it.
    # Most recent docs say: "The signature is the HMAC-SHA512 hash of the sorted list of parameters."
    
    recieved_sig = signature_header
    
    # Construct string to sign
    # "key1=value1&key2=value2..."
    # Values should be strings.
    
    # However, if the payload is nested, it's complex. Usually it's flat.
    # Let's try the standard way:
    # string_to_sign = json.dumps(payload, sort_keys=True, separators=(',', ':')) ? No.
    
    # Let's look at a standard python implementation for NOWPayments IPN.
    # "Sort all the parameters in the request alphabetically."
    # "Join them with & in the format key=value"
    
    # We will try to construct the string.
    # But wait, if we use `request_body` (bytes), maybe we can just use that if they sign the raw body?
    # Some sources say they sign the raw body.
    # Let's try to be robust.
    
    # Actually, looking at the official docs:
    # "We sign the POST request parameters with your IPN Secret Key... The signature is passed in the x-nowpayments-sig header."
    # It doesn't explicitly say "raw body". It says "request parameters".
    # So we likely need to sort.
    
    # Let's implement the sorting method.
    try:
        # Filter out 'x-nowpayments-sig' if it's in the body (unlikely)
        params = {k: v for k, v in payload.items() if k != 'x-nowpayments-sig'}
        sorted_params = sorted(params.items())
        # Join with &
        # Note: values must be converted to string.
        # Also, check if values are None.
        msg = "&".join([f"{k}={v}" for k, v in sorted_params if v is not None])
        
        calculated_sig = hmac.new(
            IPN_SECRET_KEY.encode(),
            msg.encode(),
            hashlib.sha512
        ).hexdigest()
        
        if calculated_sig != recieved_sig:
            logger.warning(f"Invalid IPN signature. Calc: {calculated_sig}, Recv: {recieved_sig}")
            # For now, we might want to return 401, but if our sorting is wrong we break it.
            # Let's log it but maybe proceed if we are in dev/debug? No, security critical.
            # We will return 401.
            return {"status": 401, "message": "Invalid signature"}
            
    except Exception as e:
        logger.error(f"Error verifying signature: {e}")
        return {"status": 500, "message": "Signature verification failed"}

    # Process payment
    payment_status = payload.get("payment_status")
    order_id = payload.get("order_id") # Format: {user_id}_{type}_{timestamp}
    invoice_id = payload.get("invoice_id")
    
    logger.info(f"Received IPN for Order {order_id}: Status {payment_status}")
    
    if payment_status in ['finished', 'confirmed']:
        if order_id:
            try:
                # Parse order_id to extract user_id and payment type
                parts = str(order_id).split('_')
                if len(parts) >= 2:
                    user_id = int(parts[0])
                    payment_type = parts[1]
                    
                    if payment_type == "subscription":
                        # Activate subscription (this also adds 250 bonus credits)
                        success = await activate_subscription(user_id, str(invoice_id))
                        if success:
                            return {"status": 200, "message": "Subscription activated"}
                        else:
                            return {"status": 500, "message": "Database update failed"}
                    
                    elif "credits" in payment_type:
                        # Add credits based on the package
                        from database_manager import add_credits
                        
                        # Extract credit amount from type (e.g., "200_credits" -> 200)
                        try:
                            credit_amount = int(payment_type.split('_')[0])
                        except:
                            credit_amount = 200  # Default fallback
                        
                        success = await add_credits(user_id, credit_amount)
                        if success:
                            logger.info(f"Added {credit_amount} credits to user {user_id}")
                            return {"status": 200, "message": f"Credits added: {credit_amount}"}
                        else:
                            return {"status": 500, "message": "Failed to add credits"}
                    
                    else:
                        logger.warning(f"Unknown payment type: {payment_type}")
                        return {"status": 400, "message": "Unknown payment type"}
                else:
                    # Legacy format or invalid
                    logger.error(f"Invalid order_id format: {order_id}")
                    return {"status": 400, "message": "Invalid order_id format"}
                    
            except ValueError:
                logger.error(f"Invalid order_id (not parsable): {order_id}")
                return {"status": 400, "message": "Invalid order_id"}
    
    return {"status": 200, "message": "OK"}
