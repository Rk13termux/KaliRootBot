import requests
import hmac
import hashlib
import json
import logging
from config import NOWPAYMENTS_API_KEY, IPN_SECRET_KEY
from database_manager import activate_subscription

logger = logging.getLogger(__name__)

NOWPAYMENTS_API_KEY = NOWPAYMENTS_API_KEY.strip() if NOWPAYMENTS_API_KEY else ""
if NOWPAYMENTS_API_KEY.startswith("sandbox"):
    NOWPAYMENTS_API_URL = "https://api-sandbox.nowpayments.io/v1"
else:
    NOWPAYMENTS_API_URL = "https://api.nowpayments.io/v1"

def create_payment_invoice(amount_usd: float, user_id: int) -> dict:
    """
    Creates a payment invoice on NOWPayments.
    Returns a dict with 'invoice_url' and 'invoice_id' or None on failure.
    """
    if not NOWPAYMENTS_API_KEY:
        logger.error("NOWPAYMENTS_API_KEY is not set")
        return None

    headers = {
        "x-api-key": NOWPAYMENTS_API_KEY,
        "Content-Type": "application/json"
    }
    
    # Using 'invoice' endpoint to get a payment link
    # Or 'payment' endpoint if we want to specify crypto immediately.
    # The user request said "Configure el pago para que sea en USDT y en la red TRC-20".
    # So we should probably use the /payment endpoint or /invoice with specific settings if possible.
    # However, /invoice usually lets the user choose unless restricted.
    # Let's try to use /invoice but passing pay_currency if supported, or just let user choose.
    # But the requirement says "Configure el pago para que sea en USDT y en la red TRC-20".
    # This implies we might want to create a direct payment or restrict the invoice.
    # NOWPayments /invoice endpoint doesn't strictly force one currency unless we use the 'pay_currency' param?
    # Let's check the docs link provided: https://documenter.getpostman.com/view/8256156/SVzVvmQ2?version=latest#66a637f8-3e9b-43b4-a5e8-5384d27b9338
    # It seems 'invoice' allows 'pay_currency'.
    
    payload = {
        "price_amount": amount_usd,
        "price_currency": "usd",
        "pay_currency": "usdttrc20", # USDT on TRC-20
        "ipn_callback_url": "", # Will be set in dashboard or we can override if needed, but usually dashboard is better or we pass it here if we have a public URL.
        # Since we don't know the public URL dynamically easily without config, we assume the dashboard has the IPN set to our webhook,
        # OR we can try to pass it if we have TELEGRAM_WEBHOOK_URL.
        "order_id": str(user_id), # Use user_id as order_id for simple tracking
        "order_description": "SuscripciÃ³n Premium KaliBot"
    }
    
    # If we have a webhook URL configured, let's append the path
    from config import TELEGRAM_WEBHOOK_URL
    if TELEGRAM_WEBHOOK_URL:
        # Assuming TELEGRAM_WEBHOOK_URL is like https://.../webhook/telegram
        # We want https://.../webhook/nowpayments
        base_url = TELEGRAM_WEBHOOK_URL.rsplit('/', 2)[0] # remove /webhook/telegram
        if '/webhook' in TELEGRAM_WEBHOOK_URL:
             base_url = TELEGRAM_WEBHOOK_URL.split('/webhook')[0]
        
        payload["ipn_callback_url"] = f"{base_url}/webhook/nowpayments"

    try:
        response = requests.post(f"{NOWPAYMENTS_API_URL}/invoice", headers=headers, json=payload)
        response.raise_for_status()
        data = response.json()
        
        return {
            "invoice_url": data.get("invoice_url"),
            "invoice_id": data.get("id")
        }
    except Exception as e:
        logger.exception(f"Error creating NOWPayments invoice: {e}")
        if 'response' in locals():
            logger.error(f"Response content: {response.text}")
        return None

async def process_nowpayments_webhook(request_body: bytes, signature_header: str) -> dict:
    """
    Verifies IPN signature and processes the payment update.
    """
    if not IPN_SECRET_KEY:
        logger.error("IPN_SECRET_KEY is not set")
        return {"status": 500, "message": "Server configuration error"}

    # Verify signature
    # NOWPayments sorts keys and signs the string representation of the JSON?
    # Actually, the docs say: "Sort all the parameters in the request alphabetically... Convert to string... Sign with HMAC-SHA512"
    # BUT, usually they send a header 'x-nowpayments-sig'.
    # Let's re-read the docs or standard practice.
    # Docs: "The IPN request contains the x-nowpayments-sig header... The signature is generated by taking the JSON body of the request..."
    # Wait, some docs say sort params.
    # Let's assume standard HMAC-SHA512 of the body for now, but if it fails we might need to sort.
    # "Sort the dictionary by keys... concatenate values..." -> This is for some APIs.
    # NOWPayments docs: "Sort all the parameters in the request alphabetically. ... create a string ... key=value&key=value..."
    # Actually, if we receive a JSON body, we might just need to sign the raw body if the header signs the body.
    # However, usually IPN sends JSON.
    # Let's try to verify the signature by sorting keys as per common NOWPayments examples.
    
    try:
        payload = json.loads(request_body)
    except json.JSONDecodeError:
        return {"status": 400, "message": "Invalid JSON"}

    # Verification logic
    # 1. Sort keys alphabetically
    sorted_keys = sorted(payload.keys())
    # 2. Create string
    # Note: NOWPayments documentation can be tricky.
    # If the signature is based on the raw body, we just hmac the request_body.
    # If it's based on sorted params, we construct it.
    # Most recent docs say: "The signature is the HMAC-SHA512 hash of the sorted list of parameters."
    
    recieved_sig = signature_header
    
    # Construct string to sign
    # "key1=value1&key2=value2..."
    # Values should be strings.
    
    # However, if the payload is nested, it's complex. Usually it's flat.
    # Let's try the standard way:
    # string_to_sign = json.dumps(payload, sort_keys=True, separators=(',', ':')) ? No.
    
    # Let's look at a standard python implementation for NOWPayments IPN.
    # "Sort all the parameters in the request alphabetically."
    # "Join them with & in the format key=value"
    
    # We will try to construct the string.
    # But wait, if we use `request_body` (bytes), maybe we can just use that if they sign the raw body?
    # Some sources say they sign the raw body.
    # Let's try to be robust.
    
    # Actually, looking at the official docs:
    # "We sign the POST request parameters with your IPN Secret Key... The signature is passed in the x-nowpayments-sig header."
    # It doesn't explicitly say "raw body". It says "request parameters".
    # So we likely need to sort.
    
    # Let's implement the sorting method.
    try:
        # Filter out 'x-nowpayments-sig' if it's in the body (unlikely)
        params = {k: v for k, v in payload.items() if k != 'x-nowpayments-sig'}
        sorted_params = sorted(params.items())
        # Join with &
        # Note: values must be converted to string.
        # Also, check if values are None.
        msg = "&".join([f"{k}={v}" for k, v in sorted_params if v is not None])
        
        calculated_sig = hmac.new(
            IPN_SECRET_KEY.encode(),
            msg.encode(),
            hashlib.sha512
        ).hexdigest()
        
        if calculated_sig != recieved_sig:
            logger.warning(f"Invalid IPN signature. Calc: {calculated_sig}, Recv: {recieved_sig}")
            # For now, we might want to return 401, but if our sorting is wrong we break it.
            # Let's log it but maybe proceed if we are in dev/debug? No, security critical.
            # We will return 401.
            return {"status": 401, "message": "Invalid signature"}
            
    except Exception as e:
        logger.error(f"Error verifying signature: {e}")
        return {"status": 500, "message": "Signature verification failed"}

    # Process payment
    payment_status = payload.get("payment_status")
    order_id = payload.get("order_id") # This is our user_id
    invoice_id = payload.get("invoice_id")
    
    logger.info(f"Received IPN for Order {order_id}: Status {payment_status}")
    
    if payment_status in ['finished', 'confirmed']:
        if order_id:
            try:
                user_id = int(order_id)
                success = await activate_subscription(user_id, str(invoice_id))
                if success:
                    return {"status": 200, "message": "Subscription activated"}
                else:
                    return {"status": 500, "message": "Database update failed"}
            except ValueError:
                logger.error(f"Invalid order_id (not an int): {order_id}")
                return {"status": 400, "message": "Invalid order_id"}
    
    return {"status": 200, "message": "OK"}
